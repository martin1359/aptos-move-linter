warning: Use `i` directly instead of comparing it to true.
    ┌─ ./sources/vector.move:176:43
    │
176 │             if (borrow(v, i) == e) return (true, i);
    │                                           ^^^^^^^^^ Use `i` directly instead of comparing it to true.

warning: Mutable parameter `v` is never modified in function `borrow_mut`.
   ┌─ ./sources/vector.move:47:5
   │
47 │     native public fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Mutable parameter `v` is never modified in function `borrow_mut`.

warning: Mutable parameter `v` is never modified in function `pop_back`.
   ┌─ ./sources/vector.move:52:5
   │
52 │     native public fun pop_back<Element>(v: &mut vector<Element>): Element;
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Mutable parameter `v` is never modified in function `pop_back`.

warning: Mutable parameter `v` is never modified in function `push_back`.
   ┌─ ./sources/vector.move:42:5
   │
42 │     native public fun push_back<Element>(v: &mut vector<Element>, e: Element);
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Mutable parameter `v` is never modified in function `push_back`.

warning: Mutable parameter `v` is never modified in function `swap`.
   ┌─ ./sources/vector.move:62:5
   │
62 │     native public fun swap<Element>(v: &mut vector<Element>, i: u64, j: u64);
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Mutable parameter `v` is never modified in function `swap`.

warning: Imports in module "acl" are not sorted alphabetically.
  ┌─ ./sources/acl.move:7:14
  │  
7 │       use std::vector;
  │ ╭──────────────^
8 │ │     use std::error;
  │ ╰──────────────────^ Imports in module "acl" are not sorted alphabetically.

warning: Detected consecutive if conditions with the same expression. Consider refactoring to avoid redundancy.
    ┌─ ./sources/bit_vector.move:106:20
    │
106 │             while (i < bitvector.length) {
    │                    ^^^^^^^^^^^^^^^^^^^^ Detected consecutive if conditions with the same expression. Consider refactoring to avoid redundancy.

warning: Detected consecutive if conditions with the same expression. Consider refactoring to avoid redundancy.
    ┌─ ./sources/bit_vector.move:200:20
    │  
200 │               while ({
    │ ╭────────────────────^
201 │ │                 spec {
202 │ │                     invariant i >= amount;
203 │ │                     invariant bitvector.length == old(bitvector).length;
    · │
208 │ │                 i < bitvector.length
209 │ │             }) {
    │ ╰─────────────^ Detected consecutive if conditions with the same expression. Consider refactoring to avoid redundancy.

warning: Detected consecutive if conditions with the same expression. Consider refactoring to avoid redundancy.
    ┌─ ./sources/bit_vector.move:218:20
    │  
218 │               while ({
    │ ╭────────────────────^
219 │ │                 spec {
220 │ │                     invariant forall j in bitvector.length - amount..i: !bitvector.bit_field[j];
221 │ │                     invariant forall k in 0..bitvector.length - amount: bitvector.bit_field[k] == old(bitvector).bit_field[k + amount];
    · │
224 │ │                 i < bitvector.length
225 │ │             }) {
    │ ╰─────────────^ Detected consecutive if conditions with the same expression. Consider refactoring to avoid redundancy.

warning: Detected consecutive if conditions with the same expression. Consider refactoring to avoid redundancy.
    ┌─ ./sources/vector.move:278:16
    │
278 │         while (len > 0) {
    │                ^^^^^^^ Detected consecutive if conditions with the same expression. Consider refactoring to avoid redundancy.

warning: Detected consecutive if conditions with the same expression. Consider refactoring to avoid redundancy.
    ┌─ ./sources/vector.move:289:16
    │
289 │         while (i < len) {
    │                ^^^^^^^ Detected consecutive if conditions with the same expression. Consider refactoring to avoid redundancy.

warning: Unused borrowed mutable variable. Consider normal borrow (borrow_global, vector::borrow, etc.) instead
    ┌─ ./sources/configs/features.move:565:29
    │
565 │         let features = &mut borrow_global_mut<Features>(@std).features;
    │                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Unused borrowed mutable variable. Consider normal borrow (borrow_global, vector::borrow, etc.) instead

warning: Unused borrowed mutable variable. Consider normal borrow (borrow_global, vector::borrow, etc.) instead
    ┌─ ./sources/configs/features.move:609:17
    │
609 │                 borrow_global_mut<Features>(@std).features = features;
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Unused borrowed mutable variable. Consider normal borrow (borrow_global, vector::borrow, etc.) instead

warning: Mutable parameter `t` is never modified in function `fill`.
    ┌─ ./sources/option.move:146:5
    │  
146 │ ╭     public fun fill<Element>(t: &mut Option<Element>, e: Element) {
147 │ │         let vec_ref = &mut t.vec;
148 │ │         if (vector::is_empty(vec_ref)) vector::push_back(vec_ref, e)
149 │ │         else abort EOPTION_IS_SET
150 │ │     }
    │ ╰─────^ Mutable parameter `t` is never modified in function `fill`.

warning: Mutable parameter `t` is never modified in function `swap_or_fill`.
    ┌─ ./sources/option.move:203:5
    │  
203 │ ╭     public fun swap_or_fill<Element>(t: &mut Option<Element>, e: Element): Option<Element> {
204 │ │         let vec_ref = &mut t.vec;
205 │ │         let old_value = if (vector::is_empty(vec_ref)) none()
206 │ │             else some(vector::pop_back(vec_ref));
207 │ │         vector::push_back(vec_ref, e);
208 │ │         old_value
209 │ │     }
    │ ╰─────^ Mutable parameter `t` is never modified in function `swap_or_fill`.

warning: Imports in module "string" are not sorted alphabetically.
  ┌─ ./sources/string.move:3:14
  │  
3 │       use std::vector;
  │ ╭──────────────^
4 │ │     use std::option::{Self, Option};
  │ ╰──────────────────────────────────^ Imports in module "string" are not sorted alphabetically.